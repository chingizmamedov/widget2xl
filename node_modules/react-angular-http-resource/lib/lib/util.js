'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunction = exports.copy = exports.extend = exports.forEach = exports.noop = undefined;
exports.pass = pass;
exports.prettyError = prettyError;
exports.isDefined = isDefined;
exports.isValidDottedPath = isValidDottedPath;
exports.lookupDottedPath = lookupDottedPath;
exports.shallowClearAndCopy = shallowClearAndCopy;
exports.encodeUriSegment = encodeUriSegment;
exports.encodeUriQuery = encodeUriQuery;
exports.extractParams = extractParams;
exports.defaultResponseInterceptor = defaultResponseInterceptor;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _constants = require('./../config/constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var noop = exports.noop = _lodash2["default"].noop;
var forEach = exports.forEach = _lodash2["default"].forEach;
var extend = exports.extend = _lodash2["default"].assign;
var copy = exports.copy = _lodash2["default"].cloneDeep;
var isFunction = exports.isFunction = _lodash2["default"].isFunction;

function pass(value) {
  return value;
}

function prettyError() {
  throw new Error(Array.prototype.join.call(arguments, ' '));
}

function isDefined(value) {
  return typeof value !== 'undefined';
}

// Helper functions and regex to lookup a dotted path on an object
// stopping at undefined/null.  The path must be composed of ASCII
// identifiers (just like $parse)
function isValidDottedPath(path) {
  return path != null && path !== '' && path !== 'hasOwnProperty' && _constants.MEMBER_NAME_REGEX.test('.' + path);
}

function lookupDottedPath(obj, path) {
  if (!isValidDottedPath(path)) {
    throw prettyError('badmember', 'Dotted member path "@{0}" is invalid.', path);
  }
  var keys = path.split('.');
  for (var i = 0, ii = keys.length; i < ii && isDefined(obj); i++) {
    var key = keys[i];
    obj = obj !== null ? obj[key] : undefined;
  }
  return obj;
}

/**
 * Create a shallow copy of an object and clear other fields from the destination
 */
function shallowClearAndCopy(src, dst) {

  dst = dst || {};

  forEach(dst, function (value, key) {
    delete dst[key];
  });

  for (var key in src) {
    if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {
      dst[key] = src[key];
    }
  }

  return dst;
}

/**
 * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set
 * (pchar) allowed in path segments:
 *    segment       = *pchar
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriSegment(val) {
  return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
}

/**
 * This method is intended for encoding *key* or *value* parts of query component. We need a
 * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't
 * have to be encoded per http://tools.ietf.org/html/rfc3986:
 *    query       = *( pchar / "/" / "?" )
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriQuery(val, pctEncodeSpaces) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
}

function extractParams(data, actionParams, paramDefaults) {
  var ids = {};
  actionParams = extend({}, paramDefaults, actionParams);
  forEach(actionParams, function (value, key) {
    if (isFunction(value)) {
      value = value();
    }
    ids[key] = value && value.charAt && value.charAt(0) == '@' ? lookupDottedPath(data, value.substr(1)) : value;
  });
  return ids;
}

function defaultResponseInterceptor(response) {
  return response.resource;
}